\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=3cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{amsthm}
\usepackage[french]{babel}
\usepackage{layout}
\usepackage{fancyhdr}
\usepackage{stmaryrd}
\usepackage{graphics}
\usepackage{comment}
\newtheorem*{thm}{Théorème}
\newtheorem{ex}{Exercice}
\newtheorem*{nota}{Notation}
\newtheorem*{rem}{Remarque}
\newtheorem*{rem2}{Remarques}
\newtheorem{de2}{Définition}
\newtheorem{pro2}[de2]{Propriété}
\newtheorem{thm2}[de2]{Théorème}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
 \newcommand{\N}{\mathbb{N}}
\title{}

\date{}
\begin{document}


\pagestyle{fancy}

\fancyhead{}
 \fancyfoot{}

 \lhead{ 2023/2024  \\  L3 Mathématiques
}
\chead{\textbf{ Calcul formel}\\} 
 \rhead{ Université de Lorraine  \\ }

\newcommand{\lb}{\llbracket}
\newcommand{\rb}{\rrbracket}
\newcommand{\Z}{\mathbb{Z}}

\newcommand{\md}[3]{#1 \equiv #2 \! \! \! \! \! \pmod {#3} }
\newcommand{\nmd}[3]{#1 \not \equiv #2 \! \! \! \! \!  \pmod #3 }
\newcommand{\mda}[3]{#1 \equiv #2 \! \!  \pmod #3 }
\newcommand{\nmda}[3]{#1 \not \equiv #2 \! \! \pmod #3 }
\newcommand{\mo}[2]{#1 \! \! \! \! \! \pmod #2 }

\thispagestyle{fancy}

\begin{center}
%    \HRule \\[0.6cm]
    { \huge \bfseries
    TP n$^{\boldsymbol{\circ}}$2: Algorithme d'Euclide
     \\ [0cm] }
    \HRule \\[0.5cm]
\end{center}

\vspace{0.01cm}



\section{Quelques remarques}

\paragraph{Variables locales/globales}
Par défaut, les variables que l'on utilise dans un programme sont des variables locales. Par exemple dans l'exemple suivant, $S$ ne peut pas être appelé en dehors du programme.

\centering\includegraphics[scale=0.5]{somme_entiers_local.png}


Il peut être pratique de transformer une variable locale en une variable globale en écrivant global $S$ (si $S$ est la variable que l'on veut rendre globale) en début du programme. On peut alors faire appel à $S$ en dehors du programme.

\centering\includegraphics[scale=0.5]{somme_entiers_global.png}

C'est parfois pratique, notamment pour déboguer un programme. Cela permet de voir où s'arrête le programme.




\paragraph{Type d'un objet}(voir «~Calcul mathématiques avec sage~» de l'inria pour plus de détails)

Dans Sage, chaque objet appartient à une «~classe~». Pour accéder à la classe d'un objet $x$, on peut taper type(x).  Par exemple $5$ est un nombre entier,  $5/3$ est un nombre rationnel, $\Z/2\Z$ est un anneau fini, ... Pour voir $5$ comme un nombre rationnel, il suffit de taper $5/1$ . Les fonctions de sage s'appliquent à une ou plusieurs classes. Si l'on tape «~IntegerModRing(18)(5)~» et $5$, sage renvoie le même résultat. En revanche, si l'on tape  «~type(IntegerModRing(18)(5)~» et «~type(5)~», sage renvoie des résultats différents. Mais si l'on tape   «~$a=$IntegerModRing(18)(5)~» et que l'on tape «~a==5~», sage renvoie «~True~». Il faut donc faire attention au type des objets lorsque l'on fait des boucles.



\subsection*{Exercice 1 (\textit{exponentiation})}
\begin{enumerate}
\item Programmer une fonction binaire($n$) qui prend en entrée un entier $n$ et qui renvoie son écriture en base $2$ (sous forme de liste).

\item[$1.$] Implanter l'algorithme d'exponentiation rapide pour calculer $x^e$ sous la forme d'une fonction notée \texttt{exporapide(x, e)}. On pourra utiliser la fonction binaire. On rappelle que calculer $x^e$ par l'exponentiation rapide consiste à calculer $\prod_{i\in \llbracket 0,k\rrbracket|a_i\neq 0 } x^{2^i}$ si $e=\sum_{i=0}^k a_i 2^i$ est l'écriture en base $2$ de $e$.
\item[$2.$] Soit $m \geqslant 2$ un entier. Adapter l'algorithme d'exponentiation rapide pour écrire une fonction \texttt{exporapidemod(x, e, m)} faisant correspondre $x^e$(mod $m$) à l'entrée ($x$,$e$)$ \in \mathbb{N}^* \times \mathbb{N}$. Comparer avec la commande \texttt{power{\_}mod} pour de <<~grandes~>> valeurs de $e$ (par exemple $e$ de l'ordre de $10^{3000}$). 
\end{enumerate}

\subsection*{Exercice 2 (\textit{Euclide})}
\begin{itemize}
\item[$1.$] Implémenter une fonction \texttt{divEucl(a, b)} de division euclidienne pour les entiers (on pourra se restreindre au cas de couples d'entiers \textit{positifs} (a,b)). Comparer ensuite avec les opérations \texttt{//} et \texttt{\%}.
\item[$2.$] Implémenter l'algorithme d'Euclide pour les entiers (on ne demande pas pour l'instant que l'algorithme renvoie des coefficients de Bezout mais simplement le pgcd du couple d'entiers donné en entrée) sous forme d'une fonction \texttt{euclide(a, b)}. Comparer avec \texttt{gcd}.
\end{itemize}



\subsection*{Exercice 3 (\textit{Euclide étendu et applications})}

\begin{itemize}
\item[$1.$] Écrire l'algorithme d'Euclide étendu  sous forme d'une fonction \texttt{euclideEtendu(a, b)}. On pourra utiliser l'algorithme 4 vu en cours plutôt que d'essayer de «~remonter~» l'algorithme d'Euclide.
%\item[$2.$] Vérifier qu'elle fonctionne encore avec des polynômes de $\mathbb{Q}[X]$.\\
%La commande \texttt{X = polygen(QQ, 'X')} définit \texttt{X} comme étant le générateur de l'anneau de polynômes $\mathbb{Q}[X]$. \\
\item[$2.$] Comparer avec \texttt{xgcd}.\\
%\item[$4.$] Écrire une fonction \texttt{sansCarre(P)} donnant la partie sans facteur carré d'un polynôme $P$ de $\mathbb{Q}[X]$ (on rappelle qu'il s'agit du produit des facteurs irréductibles 2 à 2 distincts de $P$).\\
\item[$3.$]
 \begin{itemize}
\item[•] Quelle commande \texttt{Sage} (la plus simple possible) permet d'obtenir l'inverse de 38 modulo 101?
\item[•] Écrire une procédure \texttt{inverseMod(a, m)} permettant de calculer l'inverse d'un entier $a$ premier à un entier $m \geqslant 2$ donné. Si $a$ n'est pas premier avec $m$, on renvoie : « Le nombre a n'est pas inversible modulo m ».

On pourra utiliser la fonction print. Par exemple si $a=3$, «~print(a,'est un nombre premier')~» affiche «~$3$ est un nombre premier~».
\end{itemize}

\end{itemize}



\subsection*{Exercice 4 (\textit{test de Fermat})}



\begin{enumerate}
\item  Écrire une fonction \texttt{fermat(n)} qui prend en entrée un entier positif $n$ et qui renvoie vrai si pour tout $a\in \llbracket 1,n-1\rrbracket$, $a^{n-1}\equiv 1[n]$ et faux sinon. Que doit renvoyer fermat($n$) si $n$ est premier. Tester sur quelques valeurs de $n$. 

\textit{On pourra par exemple utiliser «~power\_mod(x,e,n)~» qui renvoie $x^e\mathrm{\ mod\ }n$ ou «mod~(x,n)~» (ou de manière équivalente «~IntegerModRing(n)(x)~») qui renvoie $x\mathrm{\ mod\ }n$.}

\item  Écrire une fonction \texttt{fermat(n,k)} qui prend en entrée deux entiers positifs $n$ et $k$, qui choisit un élément de $\llbracket 1,n-1\rrbracket$ au hasard et qui vérifie si $a^{n-1}\equiv 1[n]$. Si  $a^{n-1}\not \equiv 1[n]$, la fonction s'arête et renvoie «~$n$ n'est pas premier~» et si $a^{n-1}\equiv 1[n]$ le teste recommence, jusqu'à ce que $k$ valeurs de $a$ aient été testées. Si pour toute ces valeurs, $a^{n-1}\equiv[1]$, renvoyer «~$n$ est peut-être premier~».  Tester sur quelques valeurs de $n$ pour $k=10$.  

\textit{On pourra utiliser la fonction «~ZZ.random\_element(x,y)~» qui renvoie un entier au hasard de $\llbracket x,y\llbracket$.}

\item\label{liste} Créer la liste de tous les  $a\in \llbracket 2,10^6\rrbracket$ tels que \texttt{fermat}$(a,10)$ renvoie «~$a$ est peut-être premier~» alors que $a$ n'est pas premier. On pourra utiliser la fonction is\_prime et modifier la procédure fermat$(n,k)$ pour qu'elle renvoie «~True~» ou «~False~»). Même question avec fermat(n,3) au lieu de fermat(n,10). Combien y a-t-il de nombres premiers dans $\llbracket 2,10^6\rrbracket$ ? Qu'en déduisez-vous ?

\item Écrire une fonction \texttt{proportion}($n$) qui prend en entrée un entier $n$, et qui renvoie une valeur approchée de \[\frac{|\{a\in \llbracket 1,n-1\rrbracket\mid a^{n-1}\not \equiv 1 [n]\}|}{n}.\] Calculer cette proportion pour des nombres premiers puis pour des nombres composés pris au hasard  (on rappelle qu'on a démontré en cours que pour un nombre composé qui n'est pas un nombre de Carmichaël, cette quantité est supérieure ou égale à $\frac{1}{2}$). Que constatez-vous ? Déterminer \texttt{proportion}($561$) et proportion($252601$). 


\item Prendre un élément $n$ de la liste précédente (qui fait échouer fermat(a,10)). Ce nombre est-il un nombre de Carmichael (i.e a-t-on $a^{n-1}\equiv 1[n]$ pour tous $a\in \llbracket 2,n-1\rrbracket$ tels que $a\wedge n=1$) ? Si $a\in \llbracket 2,n-1\rrbracket$ est tel que $a\wedge n\neq 1$, pourquoi a-t-on $a^{n-1}\not \equiv 1[n]$ ? Factoriser $n$ (on pourra utiliser la fonction \texttt{factor}). On suppose que $n$ s'écrit $p_1\ldots p_k$, où $p_1,\ldots,p_k$ sont des nombres premiers distincts (on verra en DM que tous les nombres de Carmichaël peuvent se mettre sous cette forme). Montrer (mathématiquement, pas informatiquement) que la proportion d'éléments $a\in \llbracket 2,n-1\rrbracket$ tels que $a^{n-1}\not \equiv 1[n]$ est inférieur à $\frac{1}{p_1}+\frac{1}{p_2}+\ldots +\frac{1}{p_k}$ (on pourra commencer par compter le nombre de multiples de $p_i$ entre $1$ et $n$, pour $i\in \llbracket 1,k\rrbracket$). Que vaut cette quantité pour le nombre choisi ? Calculer (à l'aide de l'ordinateur) \[\frac{|\{a\in \llbracket 1,n\rrbracket\mid a^{n-1}\not\equiv 1[n]\}|}{|\llbracket 1,n\rrbracket|}=\frac{|\{a\in \llbracket 1,n\rrbracket\mid a^{n-1}\not\equiv 1[n]\}|}{n}.\] Comparer avec $\frac{1}{p_1}+\ldots +\frac{1}{p_k}$. 

\item (bonus) Soit $n\in \N_{\geq 2}$. Si la décomposition de $n$ en produit de facteurs premiers s'écrit  $n=p_1^{\alpha_1}\ldots p_k^{\alpha_k}$, on pose $f(n)=\frac{1}{p_1}+\ldots +\frac{1}{p_k}$. On considère les listes $L_3$ et $L_{10}$ obtenues à la question~\ref{liste}.  Faire la liste $M_3$ (resp. $M_{10}$) des $f(i)$ tels que $i\in L_3$ (resp. $L_{10}$). Que constatez-vous ?



\subsection*{Exercice 5 : Test de Miller-Rabin}
\item On considère le pseudo-code suivant, qui vérifie si un nombre est un témoin de Miller.
\begin{itemize}
\item Entrée: un nombre impair $n$ et un nombre entier $a$ premier à $n$.
\item[(1)] Calculer $s$ et $t$ tels que $n-1=2^s\times t$ avec $t$ impair.
\item[(2)] Si $a^t \equiv 1$(mod $n$), la procédure s'arrête et l'on renvoie <<vrai>>.
\item[(3)] Sinon, on calcule $a^{t2^i}\text{ mod }n$ pour $i$ de $0$ à $s-1$: si $a^{t2^i} \equiv -1$(mod $n$), alors la procédure s'arrête et l'on renvoie <<vrai>>.
\item[(4)] On renvoie <<faux>>. 
\end{itemize}
Implémenter ce pseudo-code en une fonction \texttt{TemoinMiller(n,a)} et le tester sur quelques valeurs de $a$ et $n$. 

\item On rappelle que si $n$ est un nombre premier impair, alors il n'a pas de témoin de Miller et que si $n$  est un nombre premier composé, alors au moins les trois-quarts des $a\in \llbracket 2,n-1\rrbracket$ qui sont premiers avec $n$ sont des témoins de Miller. Implémenter un test Miller\_rabin(n,k), qui prend en entrée un entier $n$ impair et un entier $k$ (par exemple $k=5$), qui teste jusqu'à $k$  valeurs de $a\in\llbracket 1,n-1\rrbracket$ premières avec $n$ au hasard et qui renvoie «~$n$ est peut-être premier~» s'il n'a trouvé aucun témoin de Miller et qui renvoie «~$n$ est composé~» s'il a trouvé un témoin de Miller.

\end{enumerate}


\begin{comment}

\subsection*{Exercice 5 (\textit{restes chinois})}

Écrire une fonction \texttt{systemeChinois(nu, m)} qui, à partir de listes d'entiers \texttt{nu} et \texttt{m}, renvoie une solution $x$ du système de congruences
$$       x \equiv \nu_i (\text{mod } m_i), \quad 1 \leqslant i \leqslant r     $$
en supposant que les $m_i$ sont des entiers 2 à 2 premiers entre eux.


\subsection*{Exercice 6 (\textit{groupe multiplicatif})}
Soit $n \geqslant 1$ un entier. Écrire une fonction \texttt{ordre(a, n)} un couple d'entiers et renvoyant l'ordre de $a$ dans le groupe $(\mathbb{Z/n\mathbb{Z}})^{\times}$. On lèvera une exception si cette question n'a pas de sens.

\end{comment}

\end{document}